name: PR Preview (Single EC2)

on:
  pull_request:
    types: [opened, reopened, synchronize, closed]

permissions:
  id-token: write
  contents: read
  packages: write
  issues: write
  pull-requests: write

env:
  AWS_REGION: ap-northeast-1
  AMI_ID: ami-08a59875ad2a26a5f            # Amazon Linux 2023 (x86_64)
  INSTANCE_TYPE: t3.micro
  SG_ID: sg-0600751c154b62e0c              # api-sg
  SUBNET_ID: subnet-0312f79d1cf5c6bdc      # default VPC subnet
  KEY_NAME: ""                             # SSH不要
  INSTANCE_NAME: pr-preview
  INSTANCE_PROFILE: ec2-pr-preview-ssm     # SSM用ロール（PassRole許可が必要）
  PREVIEW_ACCESS_MODE: ssm                 # ssm|public

jobs:
  preview:
    runs-on: ubuntu-latest
    concurrency:
      group: pr-preview-singleton
      cancel-in-progress: true

    steps:
      - name: Decide mode (upsert or destroy)
        id: mode
        run: |
          if [ "${{ github.event.action }}" = "closed" ]; then
            echo "mode=destroy-if-no-open-pr" >> "$GITHUB_OUTPUT"
          else
            echo "mode=upsert" >> "$GITHUB_OUTPUT"
          fi

      # ===== Build & Push (same-repo PR only) =====
      - name: Checkout
        if: steps.mode.outputs.mode == 'upsert'
        uses: actions/checkout@v4

      - name: Compute image tags (lowercase)
        if: steps.mode.outputs.mode == 'upsert'
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          repo_lc="$(echo "${GITHUB_REPOSITORY}" | tr '[:upper:]' '[:lower:]')"
          echo "REPO_LC=$repo_lc" >> "$GITHUB_OUTPUT"
          echo "APP_IMAGE=ghcr.io/$repo_lc:${GITHUB_SHA}" >> "$GITHUB_ENV"
          echo "APP_IMAGE_PR=ghcr.io/$repo_lc:pr-${{ github.event.pull_request.number }}" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        if: steps.mode.outputs.mode == 'upsert'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: steps.mode.outputs.mode == 'upsert'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        if: steps.mode.outputs.mode == 'upsert' && github.event.pull_request.head.repo.fork == false
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.APP_IMAGE }}
            ${{ env.APP_IMAGE_PR }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ===== AWS Auth =====
      - name: Configure AWS creds (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::738755162207:role/github-oidc-pr-staging

      # ===== Preflight =====
      - name: "Preflight: print inputs"
        run: |
          set -x
          echo "AMI_ID=${AMI_ID}"
          echo "INSTANCE_TYPE=${INSTANCE_TYPE}"
          echo "SG_ID=${SG_ID}"
          echo "SUBNET_ID=${SUBNET_ID}"

      - name: "Preflight: check AMI arch & VPC/SG/Subnet"
        id: preflight
        run: |
          set -euo pipefail
          aws ec2 describe-images --image-ids "${AMI_ID}" --query 'Images[0].{Arch:Architecture,Name:Name,Platform:PlatformDetails}' --output table
          ARCH=$(aws ec2 describe-images --image-ids "${AMI_ID}" --query 'Images[0].Architecture' --output text)
          echo "AMI_ARCH=$ARCH"
          SG_VPC=$(aws ec2 describe-security-groups --group-ids "${SG_ID}" --query 'SecurityGroups[0].VpcId' --output text)
          SUBNET_VPC=$(aws ec2 describe-subnets --subnet-ids "${SUBNET_ID}" --query 'Subnets[0].VpcId' --output text)
          echo "SG_VPC=$SG_VPC SUBNET_VPC=$SUBNET_VPC"
          test "$SG_VPC" = "$SUBNET_VPC" || (echo "ERROR: SG and Subnet belong to different VPCs" && exit 1)
          MAP_PUBLIC=$(aws ec2 describe-subnets --subnet-ids "${SUBNET_ID}" --query 'Subnets[0].MapPublicIpOnLaunch' --output text)
          echo "MapPublicIpOnLaunch=$MAP_PUBLIC"
          echo "arch=$ARCH" >> $GITHUB_OUTPUT

      - name: "Preflight: dry-run run-instances (permission check)"
        id: dryrun
        continue-on-error: true
        run: |
          set -euo pipefail
          set -x
          aws ec2 run-instances \
            --dry-run \
            --image-id "${AMI_ID}" \
            --instance-type "${INSTANCE_TYPE}" \
            --security-group-ids "${SG_ID}" \
            --subnet-id "${SUBNET_ID}" \
            --count 1 \
            2> /tmp/dryrun.err || true
          echo "----- DRY-RUN STDERR -----"
          cat /tmp/dryrun.err || true

      - name: Interpret dry-run result
        if: steps.dryrun.outcome != 'success'
        run: |
          if grep -q "DryRunOperation" /tmp/dryrun.err; then
            echo "DryRunOperation detected -> permissions OK"
            exit 0
          fi
          echo "::error::$(cat /tmp/dryrun.err)"
          exit 1

      # ===== Upsert (create/replace) =====
      - name: Upsert single preview instance
        if: steps.mode.outputs.mode == 'upsert'
        id: upsert
        shell: bash
        env:
          DATABASE_URL: ${{ secrets.STG_DATABASE_URL }}
          SENTRY_DSN: ${{ secrets.STG_SENTRY_DSN }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
          REPO_FETCH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          REPO_REF: ${{ github.sha }}
        run: |
          set -Eeuo pipefail
          trap 'echo "::error::Failed at ${BASH_SOURCE}:${LINENO} — $BASH_COMMAND"' ERR
          set -x

          PR_NUM="${{ github.event.pull_request.number }}"
          NAME_TAG="${INSTANCE_NAME}-pr${PR_NUM}"
          PURPOSE_TAG="pr-preview-singleton"

          # 既存インスタンスを明示的に削除（機能を残す）
          IID_RAW=$(aws ec2 describe-instances \
            --filters "Name=tag:Purpose,Values=${PURPOSE_TAG}" \
                      "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null || true)
          IID_LIST=$(echo "$IID_RAW" | tr '\n' ' ' | xargs)
          echo "Found existing: '${IID_LIST:-<none>}'"
          if [ -n "$IID_LIST" ] && [ "$IID_LIST" != "None" ]; then
            aws ec2 terminate-instances --instance-ids $IID_LIST
            for id in $IID_LIST; do aws ec2 wait instance-terminated --instance-ids "$id" || true; done
          fi

          # User-Data（api+db を docker compose で起動）
          cat > user-data.template <<'UD'
          #!/bin/bash
          set -eux

          dnf -y update
          dnf -y install docker git
          systemctl enable --now docker
          usermod -aG docker ec2-user || true
          usermod -aG docker ssm-user || true
          for i in {1..30}; do [ -S /var/run/docker.sock ] && break || sleep 1; done
          chmod 666 /var/run/docker.sock || true

          # docker compose v2 (plugin) 配置
          mkdir -p /usr/local/lib/docker/cli-plugins
          curl -fL -o /usr/local/lib/docker/cli-plugins/docker-compose \
            https://github.com/docker/compose/releases/download/v2.24.6/docker-compose-linux-x86_64
          chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
          docker compose version || true

          mkdir -p /srv/app && cd /srv/app

          # GHCR ログイン（private対応）: 置換後の文字列をそのまま使う。空なら失敗しても継続。
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin || true

          # .env（アプリ用） — DB 接続は Secrets から渡す
          cat > .env <<'ENV'
          APP_PORT=8000
          ENV

          # docker-compose.yml（api のみ。DBは外部の STG を使用）
          cat > docker-compose.yml <<'YML'
          services:
            api:
              image: ${APP_IMAGE}
              env_file: .env
              environment:
                APP_ENV: stg
                ALLOW_ORIGINS: "*"
                DATABASE_URL: ${DATABASE_URL}
                SENTRY_DSN: ${SENTRY_DSN}
              restart: unless-stopped
              ports:
                - "${APP_PORT}:8000"
              command: >
                bash -lc "uvicorn app.main:app --host 0.0.0.0 --port 8000"
          YML

          # まずは pull（失敗時は後で build にフォールバック可能にしたい場合はここに処理追加可）
          set +e
          PULLED=0
          for i in {1..5}; do
            docker pull "${APP_IMAGE}" && PULLED=1 && break
            echo "pull retry ${i}"; sleep 5
          done
          set -e

          # pull に失敗したら、そのコミットのソースからローカルビルド
          if [ "${PULLED}" != "1" ]; then
            echo "Pull failed. Falling back to local build from https://api.github.com/repos/${REPO}/tarball/${REPO_REF}"
            mkdir -p /srv/src && cd /srv/src
            AUTH_ARGS=()
            if [ -n "${REPO_FETCH_TOKEN:-}" ]; then
              AUTH_ARGS=(-H "Authorization: Bearer ${REPO_FETCH_TOKEN}")
            fi
            curl -fL "${AUTH_ARGS[@]}" -o /tmp/src.tar.gz \
              "https://api.github.com/repos/${REPO}/tarball/${REPO_REF}" || {
                echo "Tarball download failed"; exit 1; }
            tar -xzf /tmp/src.tar.gz --strip-components=1 -C /srv/src
            docker build -t "${APP_IMAGE}" -f Dockerfile /srv/src
            cd /srv/app
          fi

          # Run migrations separately (one-shot). Do not block startup on transient failures; retry a few times.
          for i in {1..5}; do
            docker run --rm \
              -e DATABASE_URL="${DATABASE_URL}" \
              "${APP_IMAGE}" bash -lc "alembic upgrade head" && break || {
                echo "alembic retry ${i}"; sleep 5; }
          done

          docker compose up -d
          UD

          # user-data 変数差し込み
          safe() { printf '%s' "$1" | sed -e 's/[&]/\\&/g'; }
          APP_IMAGE_S=$(safe "${APP_IMAGE}")
          DATABASE_URL_S=$(safe "${DATABASE_URL}")
          SENTRY_DSN_S=$(safe "${SENTRY_DSN}")
          GHCR_USERNAME_S=$(safe "${GHCR_USERNAME}")
          GHCR_TOKEN_S=$(safe "${GHCR_TOKEN}")
          REPO_S=$(safe "${REPO}")
          REPO_REF_S=$(safe "${REPO_REF}")
          REPO_FETCH_TOKEN_S=$(safe "${REPO_FETCH_TOKEN}")

          # SENTRY_DSN が空なら compose から該当行を除去（空文字を渡すと Sentry SDK が失敗するため）
          if [ -z "${SENTRY_DSN}" ]; then
            sed -i.bak '/SENTRY_DSN:/d' user-data.template
          fi

          sed -e "s|\${APP_IMAGE}|${APP_IMAGE_S}|g" \
              -e "s|\${DATABASE_URL}|${DATABASE_URL_S}|g" \
              -e "s|\${SENTRY_DSN}|${SENTRY_DSN_S}|g" \
              -e "s|\${GHCR_USERNAME}|${GHCR_USERNAME_S}|g" \
              -e "s|\${GHCR_TOKEN}|${GHCR_TOKEN_S}|g" \
              -e "s|\${REPO}|${REPO_S}|g" \
              -e "s|\${REPO_REF}|${REPO_REF_S}|g" \
              -e "s|\${REPO_FETCH_TOKEN}|${REPO_FETCH_TOKEN_S}|g" user-data.template > user-data.sh

          # run-instances（タグ付け・IAMロール・Public IP）
          IID=$(aws ec2 run-instances \
            --image-id "${AMI_ID}" \
            --instance-type "${INSTANCE_TYPE}" \
            --security-group-ids "${SG_ID}" \
            --subnet-id "${SUBNET_ID}" \
            --associate-public-ip-address \
            --user-data "file://$PWD/user-data.sh" \
            --count 1 \
            --iam-instance-profile "Name=${INSTANCE_PROFILE}" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${NAME_TAG}},{Key=Purpose,Value=${PURPOSE_TAG}},{Key=Owner,Value=github-actions},{Key=Env,Value=stg},{Key=PR,Value=${PR_NUM}}]" \
            --query 'Instances[0].InstanceId' --output text)
          echo "Launched instance ID: $IID"; test -n "$IID"

          aws ec2 wait instance-running --instance-ids "$IID"
          IP=$(aws ec2 describe-instances --instance-ids "$IID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "PUBLIC_IP=${IP}" >> "$GITHUB_OUTPUT"
          echo "INSTANCE_ID=${IID}" >> "$GITHUB_OUTPUT"
          echo "Preview URL: http://${IP}:8000"

          # Optionally allow DB ingress for this instance (tcp/5432) using DB security group
          if [ -n "${{ secrets.DB_SG_ID }}" ]; then
            echo "Authorizing DB SG ${{ secrets.DB_SG_ID }} for instance IP ${IP}/32"
            aws ec2 authorize-security-group-ingress \
              --group-id "${{ secrets.DB_SG_ID }}" \
              --ip-permissions IpProtocol=tcp,FromPort=5432,ToPort=5432,IpRanges='[{CidrIp="'"${IP}"'/32",Description="pr-preview PR '${PR_NUM}'"}]' \
              || echo "DB SG ingress may already exist; continuing"
          fi

          # 外部疎通チェック（publicモード時のみ）
          if [ "${PREVIEW_ACCESS_MODE}" != "ssm" ]; then
            echo "Waiting for TCP/8000 to be reachable (public mode)..."
            for i in {1..30}; do
              if timeout 3 bash -lc "echo > /dev/tcp/${IP}/8000" 2>/dev/null; then
                echo "Port 8000 is open"; break
              fi
              echo "  retry ${i}/30 ..."; sleep 3
            done
            set +e
            curl -fsS "http://${IP}:8000/docs" >/dev/null || {
              curl -fsS "http://${IP}:8000/health" || true
              echo "::warning::App did not respond yet (container may be initializing)."
            }
            set -e
          fi

      - name: Schedule auto-stop/terminate (TTL)
        if: steps.mode.outputs.mode == 'upsert'
        shell: bash
        env:
          # 何時間後に止める/消すか（整数時間）
          PREVIEW_TTL_HOURS: "2"
          # Stop にしたいなら aws-sdk:ec2:stopInstances に差し替え
          SCHED_TARGET_ARN: "arn:aws:scheduler:::aws-sdk:ec2:terminateInstances"
          SCHED_ROLE_ARN: "arn:aws:iam::738755162207:role/eventbridge-scheduler-ec2-exec"
        run: |
          set -euo pipefail
          IID=${{ steps.upsert.outputs.INSTANCE_ID }}
          PR_NUM="${{ github.event.pull_request.number }}"
          test -n "${IID}"

          NAME="pr-preview-pr${PR_NUM}-auto-terminate"
          # UTCの now+TTL を ISO8601 で
          RUN_AT=$(date -u -d "+${PREVIEW_TTL_HOURS} hours" +"%Y-%m-%dT%H:%M:%S")
          echo "Schedule at: ${RUN_AT}"

          # 入力（ターゲットAPI入力）: InstanceIds に配列で渡す（JSON文字列化）
          INPUT=$(jq -nc --arg iid "$IID" '{InstanceIds: [$iid]}')
          TARGET=$(jq -nc --arg arn "$SCHED_TARGET_ARN" --arg role "$SCHED_ROLE_ARN" --arg input "$INPUT" '{Arn:$arn, RoleArn:$role, Input:$input}')

          # create → 失敗したら update
          set +e
          aws scheduler create-schedule \
            --name "${NAME}" \
            --schedule-expression "at(${RUN_AT})" \
            --flexible-time-window "Mode=OFF" \
            --target "$TARGET" \
            --group-name "default"
          RC=$?
          set -e
          if [ $RC -ne 0 ]; then
            echo "create-schedule failed, try update-schedule"
            aws scheduler update-schedule \
              --name "${NAME}" \
              --schedule-expression "at(${RUN_AT})" \
              --flexible-time-window "Mode=OFF" \
              --target "$TARGET" \
              --group-name "default"
          fi

          echo "Scheduled ${NAME} -> ${RUN_AT}"

      - name: Seed minimal data (SSM mode)
        if: env.PREVIEW_ACCESS_MODE == 'ssm' && steps.mode.outputs.mode == 'upsert'
        shell: bash
        run: |
          set -euo pipefail
          IID=${{ steps.upsert.outputs.INSTANCE_ID }}
          test -n "${IID}" || { echo "No INSTANCE_ID"; exit 1; }

          # --- Build multi-line command safely (wait for /srv/app & container ready) ---
          SCRIPT=$'set -euo pipefail\n\
          # 1) 待機: /srv/app が作られるまで (cloud-init/user-data 完了待ち)\n\
          for i in {1..120}; do\n\
            if [ -d /srv/app ] && [ -f /srv/app/docker-compose.yml ]; then break; fi;\n\
            echo "[seed] waiting /srv/app... ($i)"; sleep 3;\n\
          done\n\
          test -d /srv/app || { echo "[seed] /srv/app not found"; exit 1; }\n\
          cd /srv/app\n\
          # 2) 待機: docker daemon / compose 利用可\n\
          for i in {1..60}; do\n\
            docker info >/dev/null 2>&1 && docker compose version >/dev/null 2>&1 && break;\n\
            echo "[seed] waiting docker/compose... ($i)"; sleep 3;\n\
          done\n\
          # 3) 待機: api コンテナが Up になるまで\n\
          for i in {1..120}; do\n\
            st=$(docker compose -f /srv/app/docker-compose.yml ps --status running --services 2>/dev/null | grep -E "^api$" || true);\n\
            if [ -n "$st" ]; then break; fi;\n\
            echo "[seed] waiting api container... ($i)"; sleep 3;\n\
          done\n\
          # 4) マイグレーション + 最小データ投入 (数回リトライ)\n\
          for i in {1..5}; do\n\
            docker compose -f /srv/app/docker-compose.yml exec -T api bash -lc '\''alembic upgrade head'\'' && break || { echo "[seed] alembic retry $i"; sleep 5; };\n\
          done\n\
          for i in {1..5}; do\n\
            docker compose -f /srv/app/docker-compose.yml exec -T api bash -lc '\''python -m scripts.seed_minimal'\'' && break || { echo "[seed] seed retry $i"; sleep 5; };\n\
          done\n\
          echo "[seed] DONE"\n'

          PARAMS=$(jq -nc --arg cmd "$SCRIPT" '{commands: ["bash","-lc",$cmd]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${IID}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$PARAMS" \
            --query 'Command.CommandId' --output text)

          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${IID}" --query 'Status' --output text 2>/dev/null || echo 'Pending')
            if [ "${STATUS}" = "Success" ] || [ "${STATUS}" = "Failed" ]; then
              break
            fi
            sleep 2
          done

          STDOUT=$(aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${IID}" --query 'StandardOutputContent' --output text 2>/dev/null || true)
          STDERR=$(aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${IID}" --query 'StandardErrorContent' --output text 2>/dev/null || true)

          if [ -n "${STDOUT}" ] && [ "${STDOUT}" != "None" ]; then
            echo "${STDOUT}"
          fi
          if [ -n "${STDERR}" ] && [ "${STDERR}" != "None" ]; then
            echo "${STDERR}" >&2
          fi

          if [ "${STATUS}" != "Success" ]; then
            echo "::error::Seeding failed (status=${STATUS})"
            exit 1
          fi

          echo "Seeding OK"

      - name: In-instance health check via SSM (127.0.0.1)
        if: env.PREVIEW_ACCESS_MODE == 'ssm' && steps.mode.outputs.mode == 'upsert'
        shell: bash
        run: |
          set -euo pipefail
          IID=${{ steps.upsert.outputs.INSTANCE_ID }}
          test -n "${IID}" || { echo "No INSTANCE_ID"; exit 1; }
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${IID}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands='["bash","-lc","for i in {1..60}; do (curl -fsS http://127.0.0.1:8000/readyz || curl -fsS http://127.0.0.1:8000/healthz || curl -fsS http://127.0.0.1:8000/docs) >/dev/null 2>&1 && exit 0; echo retry $i; sleep 3; done; exit 1"]' \
            --query 'Command.CommandId' --output text)
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${IID}" --query 'Status' --output text 2>/dev/null || echo 'Pending')
            if [ "${STATUS}" = "Success" ]; then echo "In-instance health OK"; break; fi
            if [ "${STATUS}" = "Failed" ]; then echo "::error::In-instance health failed"; exit 1; fi
            sleep 2
          done

      - name: Comment SSM preview instructions on PR
        if: steps.mode.outputs.mode == 'upsert' && env.PREVIEW_ACCESS_MODE == 'ssm' && github.event.pull_request.head.repo.fork == false
        uses: actions/github-script@v7
        with:
          script: |
            const iid = process.env.INSTANCE_ID
            if (!iid) { core.warning('No INSTANCE_ID; skip'); return }
            const cmd = `aws ssm start-session --target ${iid} --document-name AWS-StartPortForwardingSession --parameters '{"portNumber":["8000"],"localPortNumber":["8000"]}'`
            const body = [
              'PR Preview (SSM access):',
              '',
              '1) Ensure AWS CLI v2 + session-manager-plugin',
              '2) Start port-forwarding:',
              '```',
              cmd,
              '```',
              'Open http://127.0.0.1:8000/docs'
            ].join('\n')
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
          result-encoding: string
        env:
          INSTANCE_ID: ${{ steps.upsert.outputs.INSTANCE_ID }}

      - name: Comment public preview URL on PR (public mode)
        if: steps.mode.outputs.mode == 'upsert' && env.PREVIEW_ACCESS_MODE != 'ssm' && github.event.pull_request.head.repo.fork == false && steps.upsert.outputs.PUBLIC_IP != ''
        uses: actions/github-script@v7
        with:
          script: |
            const ip = process.env.IP
            if (!ip) { core.warning('No PUBLIC_IP; skip'); return }
            const url = `http://${ip}:8000`
            const body = `PR Preview is live: ${url}`
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            })
          result-encoding: string
        env:
          IP: ${{ steps.upsert.outputs.PUBLIC_IP }}

      - name: If startup failed, collect logs via SSM and add to Summary
        if: steps.mode.outputs.mode == 'upsert'
        shell: bash
        run: |
          set -euo pipefail
          IID_LAST=$(aws ec2 describe-instances \
            --filters "Name=tag:Purpose,Values=pr-preview-singleton" "Name=instance-state-name,Values=running" \
            --query 'Reservations[-1:].Instances[-1:].InstanceId' --output text)
          if [ -z "${IID_LAST}" ] || [ "${IID_LAST}" = "None" ]; then
            echo "No running instance to collect logs from" >> "$GITHUB_STEP_SUMMARY"; exit 0; fi
          # Probe app depending on access mode
          if [ "${PREVIEW_ACCESS_MODE}" = "ssm" ]; then
            CMD_ID=$(aws ssm send-command \
              --instance-ids "${IID_LAST}" \
              --document-name "AWS-RunShellScript" \
              --parameters commands='["curl -fsS http://127.0.0.1:8000/readyz || curl -fsS http://127.0.0.1:8000/healthz || curl -fsS http://127.0.0.1:8000/docs"]' \
              --query 'Command.CommandId' --output text || true)
            if [ -n "${CMD_ID}" ]; then
              for i in {1..20}; do
                ST=$(aws ssm get-command-invocation --command-id "${CMD_ID}" --instance-id "${IID_LAST}" --query 'Status' --output text 2>/dev/null || echo 'Pending')
                [ "${ST}" = "Success" ] && { echo "In-instance health OK — no logs" >> "$GITHUB_STEP_SUMMARY"; exit 0; }
                [ "${ST}" = "Failed" ] && break
                sleep 2
              done
            fi
          else
            IP=${{ steps.upsert.outputs.PUBLIC_IP }}
            if curl -fsS "http://${IP}:8000/docs" >/dev/null; then
              echo "App responded OK — no logs collected" >> "$GITHUB_STEP_SUMMARY"; exit 0; fi
          fi
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${IID_LAST}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands='["docker compose -f /srv/app/docker-compose.yml ps -a","docker compose -f /srv/app/docker-compose.yml logs --tail=200 api || true","systemctl status docker --no-pager || true"]' \
            --query 'Command.CommandId' --output text || true)
          [ -n "${CMD_ID}" ] || { echo "Failed to send SSM command" >> "$GITHUB_STEP_SUMMARY"; exit 0; }
          for i in {1..30}; do
            OUT=$(aws ssm get-command-invocation --command-id "${CMD_ID}" --instance-id "${IID_LAST}" 2>/dev/null || true) || true
            STATUS=$(printf '%s' "${OUT}" | rg 'Status\s+:\s+(\w+)' -o -r '$1' || true)
            if [ "${STATUS}" = "Success" ] || [ "${STATUS}" = "Failed" ]; then
              echo "## Startup Logs (via SSM)" >> "$GITHUB_STEP_SUMMARY"
              echo '\n```' >> "$GITHUB_STEP_SUMMARY"
              printf '%s\n' "${OUT}" | sed -n '1,200p' >> "$GITHUB_STEP_SUMMARY"
              echo '```' >> "$GITHUB_STEP_SUMMARY"
              break
            fi
            sleep 2
          done
            
      - name: Delete auto-stop/terminate schedule on PR close
        if: steps.mode.outputs.mode == 'destroy-if-no-open-pr'
        shell: bash
        run: |
          set -euo pipefail
          PR_NUM="${{ github.event.pull_request.number }}"
          NAME="pr-preview-pr${PR_NUM}-auto-terminate"
          aws scheduler delete-schedule --name "${NAME}" --group-name "default" || true
          echo "Deleted schedule ${NAME} (if existed)"

      # ===== Destroy on PR close (no other open PRs) =====
      - name: Check remaining open PRs
        if: steps.mode.outputs.mode == 'destroy-if-no-open-pr'
        id: remain
        uses: actions/github-script@v7
        with:
          script: |
            const prs = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            core.setOutput('open_count', prs.length);

      - name: Destroy instance if no open PRs
        if: steps.mode.outputs.mode == 'destroy-if-no-open-pr' && steps.remain.outputs.open_count == '0'
        run: |
          set -euo pipefail
          PURPOSE_TAG="pr-preview-singleton"
          IID_RAW=$(aws ec2 describe-instances \
            --filters "Name=tag:Purpose,Values=${PURPOSE_TAG}" \
                      "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null || true)
          IID_LIST=$(echo "$IID_RAW" | tr '\n' ' ' | xargs)
          echo "Found to terminate: '${IID_LIST:-<none>}'"
          if [ -n "$IID_LIST" ] && [ "$IID_LIST" != "None" ]; then
            aws ec2 terminate-instances --instance-ids $IID_LIST
            for id in $IID_LIST; do aws ec2 wait instance-terminated --instance-ids "$id" || true; done
            echo "Terminated ($IID_LIST)"
          else
            echo "No instance to terminate."
          fi
